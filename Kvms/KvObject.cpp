#include "KvObject.h"
#include "KvObjectPrivate.h"
#include "KvMetaObjectPrivate.h"

static int DIRECT_CONNECTION_ONLY = 0;

//KV_CORE_EXPORT QBasicAtomicPointer<KvSignalSpyCallbackSet> qt_signal_spy_callback_set = Q_BASIC_ATOMIC_INITIALIZER(nullptr);
KvSignalSpyCallbackSet  kv_signal_spy_callback_set;
void kv_register_signal_spy_callbacks(KvSignalSpyCallbackSet *callback_set)
{
	//kv_signal_spy_callback_set.store(callback_set);
}

KvObject::KvObject(KvObject *parent /*= 0*/)
	: d_ptr(new KvObjectPrivate)
{
	d_ptr->q_ptr = this;
	if (parent)
	{
		setParent(parent);
	}
	//kv_addObject(this);
}

KvObject::~KvObject()
{
	//K_D(KvObject)

	d_func()->wasDeleted = true;
	d_func()->blockSig = 0; // unblock signals so we always emit destroyed()
}

bool KvObject::event(KvEvent *)
{
	return false;
}

bool KvObject::eventFilter(KvObject *, KvEvent *)
{
	return false;
}

KvString KvObject::objectName() const
{
	//K_D(KvObject)

	return d_func()->objectName;
}

void KvObject::setObjectName(const KvString &name)
{
	//K_D(KvObject)

	d_func()->objectName = name;
}

void KvObject::setParent(KvObject *parent)
{
	//K_D(KvObject)

	d_func()->setParent_helper(parent);
}

bool KvObject::setProperty(const char *name, const KvVariant &value)
{
	const KvMetaObject *meta = metaObject();
	if (!name || !meta)
	{
		return false;
	}

	int id = meta->indexOfProperty(name);
	if (id < 0)
	{
		//自定义、额外动态属性; TODO
	}
	
	KvMetaProperty p = meta->property(id);
	if (!p.isWritable())
	{
		printf("%s::setProperty: Property \"%s\" invalid,"
			" read-only or does not exist", metaObject()->className(), name);
	}

	return p.write(this, value);
}

KvVariant KvObject::property(const char *name)
{
	const KvMetaObject *mo = metaObject();
	if (!name || !mo)
	{
		return KvVariant();
	}

	int id = mo->indexOfProperty(name);
	if (id < 0)
	{
		//用户属性;
	}
	KvMetaProperty p = mo->property(id);
	if (!p.isReadable())
	{
		printf("%s::property: Property \"%s\" invalid or does not exist",
			metaObject()->className(), name);
	}
	return p.read(this);
}

void KvObject::installEventFilter(KvObject *)
{

}

void KvObject::removeEventFilter(KvObject *)
{

}

KvObject * KvObject::sender() const
{
	//K_D(KvObject)

	//locker TODO
	if (!d_func()->currentSender)
		return 0;
	for (KvObjectPrivate::Connection * c = d_func()->senders; c; c->next)
	{
		if (c->sender == d_func()->currentSender->sender)
		{
			return d_func()->currentSender->sender;
		}
	}

	return 0;
}

void KvObject::deleteLater()
{

}

void kv_findChildren_helper(const KvObject *parent, const KvString &name, /*const QRegExp *re,*/ const KvMetaObject &mo, KvList<void *> *list)
{

}

KvObject * kv_findChild_helper(const KvObject *parent, const KvString &name, const KvMetaObject &mo)
{
	if (!parent)
		return 0;

	const ObjectList &children = parent->children();
	KvObject *obj = 0;
	ObjectList::const_iterator it = children.begin();
	for (; it != children.end(); ++it)
	{
		obj = (*it);
		if (mo.cast(obj) && (!name.empty() || obj->objectName() == name))
		{
			return obj;
		}
	}
	
	for (; it != children.end(); ++it)
	{
		obj = kv_findChild_helper((*it), name, mo);
		if (obj)
		{
			return obj;
		}
	}

	return 0;
}


//////////////////////////////////////////////////////////////////////////


/*!\internal
For a given metaobject, compute the signal offset, and the method offset (including signals)
*/
static void computeOffsets(const KvMetaObject *metaobject, int *signalOffset, int *methodOffset)
{
	*signalOffset = *methodOffset = 0;
	const KvMetaObject *m = metaobject->d.superdata;
	while (m) {
		const KvMetaObjectPrivate *d = KvMetaObjectPrivate::get(m);
		*methodOffset += d->methodCount;
		*signalOffset += (d->revision >= 4) ? d->signalCount : d->methodCount;
		/*Before (revision 4), the signalCount information was not generated by moc.
		so for compatibility we consider all the method as slot for old moc output*/
		m = m->d.superdata;
	}
}

void KvMetaObject::activate(KvObject *sender, const KvMetaObject *m, int local_signal_index, void **argv)
{
	int signalOffset;
	int methodOffset;
	computeOffsets(m, &signalOffset, &methodOffset);

	int signal_index = signalOffset + local_signal_index;

	if (!sender->d_func()->isSignalConnected(signal_index))
		return; // nothing connected to these signals, and no spy

	if (sender->d_func()->blockSig)
		return;

	int signal_absolute_index = methodOffset + local_signal_index;
}


//////////////////////////////////////////////////////////////////////////

KvObjectData::~KvObjectData() {}

KvObjectPrivate::KvObjectPrivate(int version)
: /*threadData(0), connectionLists(0),*/ senders(0), currentSender(0)/*, currentChildBeingDeleted(0)*/
{
	if (version != 0x010000)
		printf("Cannot mix incompatible Qt library (version 0x%x) with this library (version 0x%x)",
		version, 0x010000);

	//ObjectData initialization
	q_ptr = 0;
	parent = 0;                                 // no parent yet. It is set by setParent()
	isWidget = false;                           // assume not a widget object
	pendTimer = false;                          // no timers yet
	blockSig = false;                           // not blocking signals
	wasDeleted = false;                         // double-delete catcher
	//sendChildEvents = true;                     // if we should send ChildInsert and ChildRemove events to parent
	//receiveChildEvents = true;
	//postedEvents = 0;
	extraData = 0;
	connectedSignals[0] = connectedSignals[1] = 0;
	//inThreadChangeEvent = false;

	metaObject = 0;
	//hasGuards = false;
}

KvObjectPrivate::~KvObjectPrivate()
{

}

KvObjectPrivate::Connection::~Connection()
{
	if (argumentTypes != &DIRECT_CONNECTION_ONLY)
		delete[] static_cast<int *>(argumentTypes);
}

void KvObjectPrivate::deleteChildren()
{

}

void KvObjectPrivate::setParent_helper(KvObject *)
{

}

int KvObjectPrivate::signalIndex(const char *signalName) const
{
	//K_Q(KvObject)

	const KvMetaObject *base = q_func()->metaObject();
	int relative_index = KvMetaObjectPrivate::indexOfSignalRelative(&base, signalName, false);
	if (relative_index < 0)
		relative_index = KvMetaObjectPrivate::indexOfSignalRelative(&base, signalName, true);
	if (relative_index < 0)
		return relative_index;
	relative_index = KvMetaObjectPrivate::originalClone(base, relative_index);
	int signalOffset, methodOffset;
	computeOffsets(base, &signalOffset, &methodOffset);
	return relative_index + signalOffset;
}


//////////////////////////////////////////////////////////////////////////

static const uint kv_meta_data_QObject[] = {

	// content:
	6,       // revision
	0,       // classname
	0, 0,	// classinfo
	4, 14,	// methods
	1, 34, // properties
	0, 0, // enums/sets
	2, 37, // constructors
	0,       // flags
	2,       // signalCount

	// signals: signature, parameters, type, tag, flags
	9, 8, 8, 8, 0x05,
	29, 8, 8, 8, 0x25,

	// slots: signature, parameters, type, tag, flags
	41, 8, 8, 8, 0x0a,
	55, 8, 8, 8, 0x08,

	// properties: name, type, flags
	90+3, 82, 0x0a095103,

	// constructors: signature, parameters, type, tag, flags
	108, 101, 8, 8, 0x0e,
	126, 8, 8, 8, 0x2e,

	0        // eod
};

static const char kv_meta_stringdata_QObject[] = {
	"KvObject\0\0destroyed(KvObject*)\0destroyed()\0"
	"deleteLater()\0_q_reregisterTimers(void*)\0"
	"KvString\0objectName\0parent\0KvObject(KvObject*)\0"
	"KvObject()\0"
};

void KvObject::kv_static_metacall(KvObject *_o, KvMetaObject::Call _c, int _id, void **_a)
{
	if (_c == KvMetaObject::CreateInstance) {
		switch (_id) {
		case 0: { KvObject *_r = new KvObject((*reinterpret_cast<KvObject*(*)>(_a[1])));
			if (_a[0]) *reinterpret_cast<KvObject**>(_a[0]) = _r; } break;
		case 1: { KvObject *_r = new KvObject();
			if (_a[0]) *reinterpret_cast<KvObject**>(_a[0]) = _r; } break;
		}
	}
	else if (_c == KvMetaObject::InvokeMetaMethod) {
		assert(staticMetaObject.cast(_o));
		KvObject *_t = static_cast<KvObject *>(_o);
		switch (_id) {
		case 0: _t->destroyed((*reinterpret_cast<KvObject*(*)>(_a[1]))); break;
		case 1: _t->destroyed(); break;
		case 2: _t->deleteLater(); break;
		//case 3: _t->d_func()->_q_reregisterTimers((*reinterpret_cast<void*(*)>(_a[1]))); break;
		default:;
		}
	}
}

const KvMetaObjectExtraData KvObject::staticMetaObjectExtraData = {
	0, kv_static_metacall
};

const KvMetaObject KvObject::staticMetaObject = {
	{ 0, kv_meta_stringdata_QObject,
	kv_meta_data_QObject, &staticMetaObjectExtraData }
};

#ifdef Q_NO_DATA_RELOCATION
const KvMetaObject &KvObject::getStaticMetaObject() { return staticMetaObject; }
#endif //Q_NO_DATA_RELOCATION

const KvMetaObject *KvObject::metaObject() const
{
	return KvObject::d_ptr->metaObject ? KvObject::d_ptr->metaObject : &staticMetaObject;
}

void *KvObject::kv_metacast(const char *_clname)
{
	if (!_clname) return 0;
	if (!strcmp(_clname, kv_meta_stringdata_QObject))
		return static_cast<void*>(const_cast<KvObject*>(this));
	return 0;
}

int KvObject::kv_metacall(KvMetaObject::Call _c, int _id, void **_a)
{
	if (_id < 0)
		return _id;
	if (_c == KvMetaObject::InvokeMetaMethod) {
		if (_id < 4)
			kv_static_metacall(this, _c, _id, _a);
		_id -= 4;
	}
	else if (_c == KvMetaObject::ReadProperty) {
		void *_v = _a[0];
		switch (_id) {
		case 0: *reinterpret_cast<KvString*>(_v) = objectName(); break;
		}
		_id -= 1;
	}
	else if (_c == KvMetaObject::WriteProperty) {
		void *_v = _a[0];
		switch (_id) {
		case 0: setObjectName(*reinterpret_cast<KvString*>(_v)); break;
		}
		_id -= 1;
	}
	else if (_c == KvMetaObject::ResetProperty) {
		_id -= 1;
	}
	else if (_c == KvMetaObject::QueryPropertyDesignable) {
		_id -= 1;
	}
	else if (_c == KvMetaObject::QueryPropertyScriptable) {
		_id -= 1;
	}
	else if (_c == KvMetaObject::QueryPropertyStored) {
		_id -= 1;
	}
	else if (_c == KvMetaObject::QueryPropertyEditable) {
		_id -= 1;
	}
	else if (_c == KvMetaObject::QueryPropertyUser) {
		_id -= 1;
	}
	return _id;
}

// SIGNAL 0
void KvObject::destroyed(KvObject * _t1)
{
	void *_a[] = { 0, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
	KvMetaObject::activate(this, &staticMetaObject, 0, _a);
}
